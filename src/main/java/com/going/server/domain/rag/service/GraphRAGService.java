package com.going.server.domain.rag.service;

import com.going.server.domain.chatbot.dto.CreateChatbotResponseDto;
import com.going.server.domain.chatbot.entity.Chatting;
import com.going.server.domain.chatbot.repository.ChattingRepository;
import com.going.server.domain.graph.entity.Graph;
import com.going.server.domain.graph.repository.GraphNodeRepository;
import com.going.server.domain.graph.repository.GraphRepository;
import com.going.server.domain.rag.dto.GraphQueryResult;
import com.going.server.domain.rag.util.PromptBuilder;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Service
@RequiredArgsConstructor
@Slf4j
public class GraphRAGService {

    private final GraphRepository graphRepository;
    private final GraphNodeRepository graphNodeRepository;
    private final SimilarityFilterService similarityFilterService;
    private final PromptBuilder promptBuilder;
    private final ChattingRepository chattingRepository;
    private final CypherQueryGenerator cypherQueryGenerator;
    private final GraphQueryExecutor graphQueryExecutor;
    private final RagAnswerCreateService ragAnswerCreateService;

    /**
     * 사용자 질문에 대해 Cypher 쿼리 → 그래프 정보 검색 → 프롬프트 생성 → LLM 응답 생성
     * LangChain 없이 구현한 Spring 기반 GraphRAG의 핵심 흐름
     */
    public CreateChatbotResponseDto createAnswerWithGraphRAG(
            Long dbId,
            String userQuestion,
            List<Chatting> chatHistory
    ) {
        Graph graph = graphRepository.getByGraph(dbId);
        log.info("[GraphRAG] dbId: {}, question: {}", dbId, userQuestion);

        // 1. 질문 → Cypher 쿼리 생성
        String rawQuery = cypherQueryGenerator.generate(userQuestion);
            // ```cypher ~ ``` 블록 제거
        Matcher m = Pattern.compile("(?s)```cypher\\s*(.*?)\\s*```").matcher(rawQuery);
        String cleaned = m.find() ? m.group(1) : rawQuery;
            // 남은 ``` 제거
        cleaned = cleaned.replaceAll("```", "").trim();
        log.info("[GraphRAG] Cypher Query 생성됨:\n----\n{}\n----", cleaned);

        // 2. 쿼리 실행 → 문맥(context) 및 노드 라벨 추출
        List<GraphQueryResult> queryResults = graphQueryExecutor.runQuery(dbId, cleaned);
            // 문장
        List<String> contextChunks = queryResults.stream()
                .map(GraphQueryResult::getSentence)
                .toList();
            // 관계 트리플
        List<String> retrievedTriples = queryResults.stream()
                .map(GraphQueryResult::toTripleString)
                .distinct()
                .toList();
            // 노드
        List<String> sourceNodes = queryResults.stream()
                .map(GraphQueryResult::getNodeLabel)
                .filter(n -> n != null && !n.isBlank())
                .distinct()
                .toList();

        log.info("[GraphRAG] Retrieved {} context chunks", contextChunks.size());
        retrievedTriples.forEach(triple ->
                log.info("[GraphRAG] Triple: {}", triple)
        );
        log.info("[GraphRAG] Retrieved {} triples", retrievedTriples.size());

        // 3. 프롬프트 구성
        String finalPrompt = promptBuilder.buildPrompt(contextChunks, retrievedTriples, userQuestion);
        log.info("[GraphRAG] Final Prompt constructed");

        // 4. RAG 응답 생성
        boolean hasContext = !contextChunks.isEmpty() || !retrievedTriples.isEmpty();
        String response = hasContext
                ? ragAnswerCreateService.chatWithContext(chatHistory, finalPrompt)
                : ragAnswerCreateService.chat(chatHistory, userQuestion);
        log.info("[GraphRAG] Response generated by LLM");

        // 5. 응답 저장
        Chatting answer = Chatting.ofGPT(graph, response);
        chattingRepository.save(answer);

        return CreateChatbotResponseDto.of(
                response,
                dbId.toString(),
                answer.getCreatedAt(),
                contextChunks,
                retrievedTriples,
                sourceNodes
        );
    }
}
