package com.going.server.domain.rag.service;

import com.going.server.domain.chatbot.dto.CreateChatbotResponseDto;
import com.going.server.domain.chatbot.entity.Chatting;
import com.going.server.domain.chatbot.repository.ChattingRepository;
import com.going.server.domain.graph.entity.Graph;
import com.going.server.domain.graph.repository.GraphNodeRepository;
import com.going.server.domain.graph.repository.GraphRepository;
import com.going.server.domain.rag.dto.GraphQueryResult;
import com.going.server.domain.rag.util.PromptBuilder;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class GraphRAGService {

    private final GraphRepository graphRepository;
    private final GraphNodeRepository graphNodeRepository;
    private final SimilarityFilterService similarityFilterService;
    private final PromptBuilder promptBuilder;
    private final ChattingRepository chattingRepository;
    private final CypherQueryGenerator cypherQueryGenerator;
    private final GraphQueryExecutor graphQueryExecutor;
    private final RagAnswerCreateService ragAnswerCreateService;

    /**
     * 사용자 질문에 대해 Cypher 쿼리 → 그래프 정보 검색 → 프롬프트 생성 → LLM 응답 생성
     * 본 메서드는 LangChain 없이 구현한 Spring 기반 GraphRAG의 핵심 흐름입니다.
     *
     *     private LocalDateTime createdAt;
     *     private List<String> retrievedTriples; //관계 중심의 3요소 표현 ("물 -상태변화→ 응고")
     *     private List<String> sourceNodes; //질의에 사용된 핵심 노드들 ("물", "응고" 등)
     *     private List<String> 증강할때쓴자료; //LLM에 넘긴 context 문장들 (이름은 `augmentedSentences` 등으로 변경 권장)
     *     -> 이렇게 결과 나오도록 정리
     */
    public CreateChatbotResponseDto createAnswerWithGraphRAG(
            Long dbId,
            String userQuestion,
            List<Chatting> chatHistory
    ) {
        Graph graph = graphRepository.getByGraph(dbId);
        log.info("[GraphRAG] dbId: {}, question: {}", dbId, userQuestion);

        // 1. 질문 → Cypher 쿼리 생성
        String cypherQuery = cypherQueryGenerator.generate(userQuestion).trim()
                .replaceAll("(?s)```cypher.*?```", "") // 마크다운 제거
                .replaceAll("```", "")                // 남은 ``` 제거
                .trim();
        log.info("[GraphRAG] Generated Cypher Query:\n{}", cypherQuery);

        // 2. 쿼리 실행 → 문맥(context) 및 노드 라벨 추출
        List<GraphQueryResult> queryResults = graphQueryExecutor.runQuery(dbId, cypherQuery);
        List<String> contextChunks = queryResults.stream()
                .map(GraphQueryResult::getSentence)
                .toList();

        List<String> sourceNodes = queryResults.stream()
                .map(GraphQueryResult::getNodeLabel)
                .distinct()
                .toList();
        log.info("[GraphRAG] Retrieved {} context chunks", contextChunks.size());

        // 3. 프롬프트 구성
        String finalPrompt = promptBuilder.buildPrompt(contextChunks, userQuestion);
        log.info("[GraphRAG] Final Prompt constructed");

        // 4. RAG 응답 생성
        String response = contextChunks.isEmpty()
                ? ragAnswerCreateService.chat(chatHistory, userQuestion)
                : ragAnswerCreateService.chatWithContext(chatHistory, finalPrompt);
        log.info("[GraphRAG] Response generated by LLM");

        // 5. 응답 저장
        Chatting answer = Chatting.ofGPT(graph, response);
        chattingRepository.save(answer);
        log.info("[GraphRAG] Response saved to DB");

        // 임시 retrievedTriples 설정
        List<String> retrievedTriples = List.of(
                "(물)-[:RELATED {label: '상태변화'}]->(기화)",
                "(기화)-[:RELATED {label: '조건'}]->(높은 온도)",
                "(수증기)-[:RELATED {label: '응결'}]->(물방울)",
                "(물)-[:RELATED {label: '응고'}]->(얼음)",
                "(응고)-[:RELATED {label: '예시'}]->(겨울철 얼어붙은 길)"
        );

        return CreateChatbotResponseDto.of(
                response,
                dbId.toString(),
                answer.getCreatedAt(),
                retrievedTriples,
                sourceNodes
        );
    }
}
